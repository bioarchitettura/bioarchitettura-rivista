/**
 * OpenAI Service for Bioarchitettura Rivista
 * Handles all OpenAI API interactions with error handling and retry logic
 */

const { OpenAI } = require('openai');
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console()
  ]
});

class OpenAIService {
  constructor() {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY environment variable is required');
    }
    
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
      timeout: 30000, // 30 seconds timeout
      maxRetries: 3
    });
    
    this.bioarchKeywords = [
      'bioarchitettura', 'sostenibile', 'sostenibilità', 'ecologico', 'ecologia',
      'naturale', 'biologico', 'bio', 'verde', 'ambiente', 'ambientale',
      'efficienza', 'energetica', 'energia', 'rinnovabile', 'passiva', 'passivo',
      'materiali', 'legno', 'paglia', 'terra', 'canapa', 'sughero',
      'isolamento', 'isolante', 'termico', 'acustico', 'traspirante',
      'costruzione', 'edificio', 'casa', 'abitazione', 'architettura'
    ];
  }

  /**
   * Generate summary using OpenAI GPT
   * @param {Object} options - Summarization options
   * @param {string} options.content - Content to summarize
   * @param {string} options.title - Optional title
   * @param {string} options.model - GPT model to use
   * @param {number} options.maxTokens - Maximum tokens for response
   * @param {number} options.temperature - Creativity level (0-1)
   * @returns {Promise<Object>} Summary result
   */
  async summarize({ content, title = '', model = 'gpt-3.5-turbo', maxTokens = 150, temperature = 0.7 }) {
    try {
      // Validate input
      if (!content || content.length < 50) {
        throw new Error('Content too short for summarization');
      }
      
      if (content.length > 40000) {
        content = content.substring(0, 40000) + '...';
      }
      
      // Create context-aware prompt for bioarchitecture content
      const systemPrompt = `Sei un esperto di bioarchitettura e sostenibilità edilizia. 
Il tuo compito è creare riassunti concisi e informativi di articoli tecnici sulla bioarchitettura.
Concentrati sui concetti chiave, le tecnologie innovative, i benefici ambientali e le applicazioni pratiche.
Il riassunto deve essere professionale, accurato e accessibile anche ai non specialisti.
Usa terminologia tecnica appropriata ma spiega i concetti complessi.
Massimo ${maxTokens} token per il riassunto.`;

      const userPrompt = title 
        ? `Riassumi questo articolo di bioarchitettura:\n\nTitolo: ${title}\n\nContenuto: ${content}`
        : `Riassumi questo contenuto di bioarchitettura:\n\n${content}`;

      logger.info(`Starting OpenAI summarization with model ${model}`);

      const response = await this.client.chat.completions.create({
        model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: maxTokens,
        temperature,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      });

      const summary = response.choices[0]?.message?.content?.trim();
      
      if (!summary) {
        throw new Error('No summary generated by OpenAI');
      }

      // Extract bioarchitecture-specific insights
      const insights = this.extractBioarchInsights(summary);
      
      const result = {
        summary,
        insights,
        usage: response.usage,
        model,
        method: 'OpenAI GPT',
        timestamp: new Date().toISOString(),
        wordCount: summary.split(/\s+/).length,
        originalLength: content.length,
        compressionRatio: Math.round((1 - summary.length / content.length) * 100)
      };

      logger.info(`OpenAI summarization completed successfully, ${result.usage.total_tokens} tokens used`);
      
      return result;

    } catch (error) {
      logger.error('OpenAI summarization error:', error);
      
      // Enhanced error handling
      if (error.code === 'insufficient_quota') {
        throw new Error('Quota OpenAI esaurita. Contatta l\'amministratore.');
      } else if (error.code === 'model_not_found') {
        throw new Error(`Modello ${model} non disponibile.`);
      } else if (error.code === 'context_length_exceeded') {
        throw new Error('Contenuto troppo lungo per il modello selezionato.');
      } else if (error.code === 'rate_limit_exceeded') {
        throw new Error('Limite velocità OpenAI superato. Riprova tra qualche minuto.');
      }
      
      throw new Error(`Errore OpenAI: ${error.message}`);
    }
  }

  /**
   * Generate article recommendations using OpenAI
   * @param {Object} options - Recommendation options
   * @param {Object} options.currentPost - Current post data
   * @param {Array} options.posts - All available posts
   * @param {number} options.maxRecommendations - Maximum recommendations
   * @returns {Promise<Array>} Recommended articles
   */
  async generateRecommendations({ currentPost, posts, maxRecommendations = 3 }) {
    try {
      const systemPrompt = `Sei un esperto curatore di contenuti per una rivista di bioarchitettura.
Il tuo compito è raccomandare articoli correlati che siano rilevanti e interessanti per i lettori.
Considera temi come sostenibilità, materiali naturali, efficienza energetica, innovazione tecnologica.
Fornisci una risposta JSON con un array di ID articoli raccomandati ordinati per rilevanza.`;

      const userPrompt = `Articolo corrente:
Titolo: ${currentPost.title}
Categoria: ${currentPost.category || 'N/A'}
Tags: ${(currentPost.tags || []).join(', ')}
Estratto: ${currentPost.excerpt || ''}

Articoli disponibili:
${posts.map((post, index) => 
  `${index}: ${post.title} (${post.category || 'N/A'}) - ${post.excerpt || ''}`
).join('\n')}

Raccomanda ${maxRecommendations} articoli più rilevanti (escludendo l'articolo corrente).
Rispondi solo con JSON: {"recommendations": [index1, index2, index3]}`;

      const response = await this.client.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: 200,
        temperature: 0.3
      });

      const result = JSON.parse(response.choices[0].message.content);
      
      return result.recommendations
        .slice(0, maxRecommendations)
        .map(index => posts[index])
        .filter(post => post && post.url !== currentPost.url);

    } catch (error) {
      logger.error('OpenAI recommendations error:', error);
      throw new Error(`Errore generazione raccomandazioni: ${error.message}`);
    }
  }

  /**
   * Extract bioarchitecture-specific insights from text
   * @param {string} text - Text to analyze
   * @returns {Array} Array of insights
   */
  extractBioarchInsights(text) {
    const insights = [];
    const lowerText = text.toLowerCase();

    // Check for bioarchitecture keywords
    const foundKeywords = this.bioarchKeywords.filter(keyword => 
      lowerText.includes(keyword)
    );

    if (foundKeywords.length > 0) {
      insights.push({
        type: 'keywords',
        value: foundKeywords.slice(0, 5), // Top 5 keywords
        description: 'Concetti chiave di bioarchitettura identificati'
      });
    }

    // Check for sustainability indicators
    const sustainabilityTerms = [
      'sostenibile', 'eco-friendly', 'green', 'rinnovabile', 'riciclabile',
      'carbon neutral', 'emissioni zero', 'impatto ambientale'
    ];
    
    const sustainabilityFound = sustainabilityTerms.filter(term => 
      lowerText.includes(term)
    );

    if (sustainabilityFound.length > 0) {
      insights.push({
        type: 'sustainability',
        value: sustainabilityFound,
        description: 'Indicatori di sostenibilità'
      });
    }

    // Check for innovation indicators
    const innovationTerms = [
      'innovativo', 'tecnologia', 'smart', 'intelligente', 'automatico',
      'AI', 'IoT', 'sensori', 'monitoraggio'
    ];
    
    const innovationFound = innovationTerms.filter(term => 
      lowerText.includes(term)
    );

    if (innovationFound.length > 0) {
      insights.push({
        type: 'innovation',
        value: innovationFound,
        description: 'Elementi di innovazione tecnologica'
      });
    }

    return insights;
  }

  /**
   * Check if OpenAI service is available
   * @returns {Promise<boolean>} Service availability
   */
  async checkHealth() {
    try {
      const response = await this.client.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: 'Test' }],
        max_tokens: 5
      });
      
      return response.choices[0]?.message?.content !== undefined;
    } catch (error) {
      logger.error('OpenAI health check failed:', error);
      return false;
    }
  }
}

module.exports = new OpenAIService();