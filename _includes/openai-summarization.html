<!-- OpenAI Auto-Summarization Component -->
<div class="openai-summarization" id="openai-summarization">
    <div class="summary-header">
        <h3 class="summary-title" data-translate="summary.title">Riassunto AI</h3>
        <div class="summary-controls">
            <button class="summary-refresh" id="summary-refresh" title="Rigenera riassunto" aria-label="Rigenera riassunto">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="m3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
            </button>
            <button class="summary-toggle" id="summary-toggle" data-translate="summary.hide">Nascondi</button>
        </div>
    </div>
    
    <div class="summary-content" id="summary-content">
        <div class="summary-loading" id="summary-loading">
            <div class="loading-spinner"></div>
            <span data-translate="summary.generating">Generando riassunto con AI...</span>
        </div>
        
        <div class="summary-text" id="summary-text" style="display: none;">
            <!-- AI generated summary will be inserted here -->
        </div>
        
        <div class="summary-error" id="summary-error" style="display: none;">
            <div class="error-icon">⚠️</div>
            <div class="error-message">
                <p data-translate="summary.error">Impossibile generare il riassunto AI. Usando algoritmo di backup...</p>
                <button class="retry-btn" id="retry-summary" data-translate="summary.retry">Riprova</button>
            </div>
        </div>
    </div>
    
    <div class="summary-footer">
        <div class="summary-info">
            <span class="summary-method" id="summary-method"></span>
            <span class="summary-stats" id="summary-stats"></span>
        </div>
        <div class="summary-actions">
            <button class="copy-summary" id="copy-summary" title="Copia riassunto" aria-label="Copia riassunto">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="m5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
            </button>
        </div>
    </div>
</div>

<script>
// OpenAI Summarization Engine
class OpenAISummarizer {
    constructor(options = {}) {
        this.apiKey = options.apiKey || '{{ site.openai.api_key }}';
        this.model = options.model || '{{ site.openai.model | default: "gpt-3.5-turbo" }}';
        this.maxTokens = options.maxTokens || {{ site.openai.max_tokens | default: 150 }};
        this.temperature = options.temperature || {{ site.openai.temperature | default: 0.7 }};
        this.fallbackEnabled = options.fallbackEnabled !== false;
        this.articleContent = options.articleContent || '';
        this.articleTitle = options.articleTitle || '';
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.generateSummary();
    }
    
    bindEvents() {
        const refreshBtn = document.getElementById('summary-refresh');
        const toggleBtn = document.getElementById('summary-toggle');
        const retryBtn = document.getElementById('retry-summary');
        const copyBtn = document.getElementById('copy-summary');
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.generateSummary(true));
        }
        
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => this.toggleSummary());
        }
        
        if (retryBtn) {
            retryBtn.addEventListener('click', () => this.generateSummary(true));
        }
        
        if (copyBtn) {
            copyBtn.addEventListener('click', () => this.copySummary());
        }
    }
    
    async generateSummary(force = false) {
        const loadingEl = document.getElementById('summary-loading');
        const textEl = document.getElementById('summary-text');
        const errorEl = document.getElementById('summary-error');
        const methodEl = document.getElementById('summary-method');
        const statsEl = document.getElementById('summary-stats');
        
        // Check if we already have a summary and not forcing regeneration
        if (!force && textEl && textEl.textContent.trim()) {
            return;
        }
        
        // Show loading state
        if (loadingEl) loadingEl.style.display = 'flex';
        if (textEl) textEl.style.display = 'none';
        if (errorEl) errorEl.style.display = 'none';
        
        try {
            let summary = '';
            let method = '';
            let stats = '';
            
            // Try OpenAI first if API key is available
            if (this.apiKey && this.apiKey !== '') {
                try {
                    const result = await this.generateOpenAISummary();
                    summary = result.summary;
                    method = 'OpenAI GPT';
                    stats = `${result.tokens} tokens utilizzati`;
                } catch (error) {
                    console.warn('OpenAI summarization failed:', error);
                    if (this.fallbackEnabled) {
                        const result = this.generateFallbackSummary();
                        summary = result.summary;
                        method = 'Algoritmo Estrattivo';
                        stats = `${result.sentences} frasi estratte`;
                    } else {
                        throw error;
                    }
                }
            } else if (this.fallbackEnabled) {
                // Use fallback if no API key
                const result = this.generateFallbackSummary();
                summary = result.summary;
                method = 'Algoritmo Estrattivo';
                stats = `${result.sentences} frasi estratte`;
            } else {
                throw new Error('Nessun metodo di riassunto disponibile');
            }
            
            // Display summary
            if (textEl) {
                textEl.innerHTML = this.formatSummary(summary);
                textEl.style.display = 'block';
            }
            
            if (methodEl) methodEl.textContent = `Generato con: ${method}`;
            if (statsEl) statsEl.textContent = stats;
            
        } catch (error) {
            console.error('Summary generation failed:', error);
            if (errorEl) errorEl.style.display = 'block';
        } finally {
            if (loadingEl) loadingEl.style.display = 'none';
        }
    }
    
    async generateOpenAISummary() {
        const apiEndpoint = '/api/openai/summarize'; // Backend API endpoint
        
        const response = await fetch(apiEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                content: this.articleContent,
                title: this.articleTitle,
                model: this.model,
                maxTokens: this.maxTokens,
                temperature: this.temperature
            })
        });
        
        if (!response.ok) {
            throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        return {
            summary: data.summary,
            tokens: data.usage?.total_tokens || 0
        };
    }
    
    generateFallbackSummary() {
        // Simple extractive summarization algorithm
        const content = this.cleanContent(this.articleContent);
        const sentences = this.splitIntoSentences(content);
        
        if (sentences.length <= 3) {
            return {
                summary: sentences.join(' '),
                sentences: sentences.length
            };
        }
        
        // Score sentences based on various factors
        const scoredSentences = this.scoreSentences(sentences);
        
        // Select top sentences
        const topSentences = scoredSentences
            .sort((a, b) => b.score - a.score)
            .slice(0, Math.min(3, Math.ceil(sentences.length * 0.3)))
            .sort((a, b) => a.index - b.index) // Maintain original order
            .map(item => item.sentence);
        
        return {
            summary: topSentences.join(' '),
            sentences: topSentences.length
        };
    }
    
    cleanContent(content) {
        // Remove HTML tags and clean up text
        const div = document.createElement('div');
        div.innerHTML = content;
        
        // Remove script and style elements
        const scripts = div.querySelectorAll('script, style');
        scripts.forEach(el => el.remove());
        
        return div.textContent || div.innerText || '';
    }
    
    splitIntoSentences(text) {
        // Simple sentence splitting (could be improved with more sophisticated NLP)
        return text
            .split(/[.!?]+/)
            .map(s => s.trim())
            .filter(s => s.length > 20) // Filter out very short sentences
            .map(s => s + '.');
    }
    
    scoreSentences(sentences) {
        const keywords = this.extractKeywords();
        
        return sentences.map((sentence, index) => {
            let score = 0;
            
            // Position scoring (earlier sentences get higher score)
            score += (sentences.length - index) / sentences.length * 0.3;
            
            // Length scoring (prefer medium-length sentences)
            const idealLength = 100;
            const lengthScore = 1 - Math.abs(sentence.length - idealLength) / idealLength;
            score += Math.max(0, lengthScore) * 0.2;
            
            // Keyword scoring
            const sentenceLower = sentence.toLowerCase();
            keywords.forEach(keyword => {
                if (sentenceLower.includes(keyword.toLowerCase())) {
                    score += 0.5;
                }
            });
            
            // Avoid sentences with too many numbers or short words
            const words = sentence.split(/\s+/);
            const shortWords = words.filter(w => w.length <= 3).length;
            const numbers = (sentence.match(/\d+/g) || []).length;
            score -= (shortWords / words.length) * 0.2;
            score -= (numbers / words.length) * 0.1;
            
            return { sentence, score, index };
        });
    }
    
    extractKeywords() {
        // Extract keywords from title and content
        const keywords = [];
        
        if (this.articleTitle) {
            keywords.push(...this.articleTitle.split(/\s+/).filter(w => w.length > 3));
        }
        
        // Add common bioarchitecture terms
        keywords.push(
            'bioarchitettura', 'sostenibile', 'ecologico', 'naturale',
            'efficienza', 'energetica', 'materiali', 'costruzione',
            'ambiente', 'verde', 'passiva', 'biologico'
        );
        
        return [...new Set(keywords)]; // Remove duplicates
    }
    
    formatSummary(summary) {
        // Add basic formatting to the summary
        return `<p class="summary-paragraph">${summary}</p>`;
    }
    
    toggleSummary() {
        const summaryEl = document.getElementById('openai-summarization');
        const toggleBtn = document.getElementById('summary-toggle');
        const contentEl = document.getElementById('summary-content');
        
        if (contentEl) {
            const isVisible = contentEl.style.display !== 'none';
            contentEl.style.display = isVisible ? 'none' : 'block';
            
            if (toggleBtn) {
                toggleBtn.textContent = isVisible ? 'Mostra' : 'Nascondi';
                toggleBtn.setAttribute('data-translate', isVisible ? 'summary.show' : 'summary.hide');
            }
        }
    }
    
    async copySummary() {
        const textEl = document.getElementById('summary-text');
        const copyBtn = document.getElementById('copy-summary');
        
        if (textEl && textEl.textContent) {
            try {
                await navigator.clipboard.writeText(textEl.textContent);
                
                // Visual feedback
                if (copyBtn) {
                    const originalContent = copyBtn.innerHTML;
                    copyBtn.innerHTML = '✓';
                    copyBtn.style.color = '#28a745';
                    
                    setTimeout(() => {
                        copyBtn.innerHTML = originalContent;
                        copyBtn.style.color = '';
                    }, 2000);
                }
                
                // Show notification
                this.showNotification('Riassunto copiato negli appunti!', 'success');
                
            } catch (error) {
                console.error('Failed to copy summary:', error);
                this.showNotification('Errore durante la copia', 'error');
            }
        }
    }
    
    showNotification(message, type = 'info') {
        // Simple notification system
        const notification = document.createElement('div');
        notification.className = `summary-notification ${type}`;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
}

// Auto-initialize on post pages
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeOpenAISummarizer);
} else {
    initializeOpenAISummarizer();
}

function initializeOpenAISummarizer() {
    const summaryElement = document.getElementById('openai-summarization');
    
    if (summaryElement) {
        // Extract article content
        const contentElement = document.querySelector('.post-content .content-body, .content-body, .post-content');
        const titleElement = document.querySelector('.post-title, h1');
        
        const articleContent = contentElement ? contentElement.textContent || contentElement.innerText : '';
        const articleTitle = titleElement ? titleElement.textContent || titleElement.innerText : '';
        
        if (articleContent.length > 100) { // Only summarize substantial content
            new OpenAISummarizer({
                articleContent,
                articleTitle,
                apiKey: '{{ site.openai.api_key }}'
            });
        } else {
            // Hide summarizer if content is too short
            summaryElement.style.display = 'none';
        }
    }
}
</script>

<style>
.openai-summarization {
    margin: 2rem 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
}

.summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.summary-title {
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.summary-title::before {
    content: '🤖';
    font-size: 1.5rem;
}

.summary-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.summary-refresh,
.summary-toggle {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.875rem;
}

.summary-refresh {
    padding: 0.5rem 0.75rem;
    display: flex;
    align-items: center;
}

.summary-refresh:hover,
.summary-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
}

.summary-content {
    margin-bottom: 1rem;
}

.summary-loading {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1.5rem;
    justify-content: center;
    color: rgba(255, 255, 255, 0.9);
}

.summary-text {
    background: rgba(255, 255, 255, 0.1);
    padding: 1.25rem;
    border-radius: 8px;
    border-left: 4px solid rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(10px);
}

.summary-paragraph {
    margin: 0;
    line-height: 1.6;
    font-size: 1rem;
}

.summary-error {
    background: rgba(220, 53, 69, 0.2);
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid rgba(220, 53, 69, 0.4);
    display: flex;
    gap: 1rem;
    align-items: center;
}

.error-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.error-message {
    flex: 1;
}

.error-message p {
    margin: 0 0 0.5rem 0;
}

.retry-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 0.375rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.875rem;
    transition: all 0.2s ease;
}

.retry-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.summary-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.875rem;
    opacity: 0.9;
}

.summary-info {
    display: flex;
    gap: 1rem;
}

.summary-method {
    font-weight: 500;
}

.summary-stats {
    opacity: 0.7;
}

.copy-summary {
    background: transparent;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 0.375rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
}

.copy-summary:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-1px);
}

.summary-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    border-radius: 6px;
    color: white;
    font-weight: 500;
    z-index: 1000;
    animation: slideInRight 0.3s ease;
}

.summary-notification.success {
    background: #28a745;
}

.summary-notification.error {
    background: #dc3545;
}

@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@media (max-width: 768px) {
    .summary-header {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
    }
    
    .summary-controls {
        justify-content: space-between;
    }
    
    .summary-footer {
        flex-direction: column;
        gap: 0.75rem;
        align-items: stretch;
        text-align: center;
    }
    
    .summary-info {
        flex-direction: column;
        gap: 0.25rem;
    }
}
</style>